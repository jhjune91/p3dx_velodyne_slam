// Generated by gencpp from file map_file/Lane.msg
// DO NOT EDIT!


#ifndef MAP_FILE_MESSAGE_LANE_H
#define MAP_FILE_MESSAGE_LANE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace map_file
{
template <class ContainerAllocator>
struct Lane_
{
  typedef Lane_<ContainerAllocator> Type;

  Lane_()
    : lnid(0)
    , did(0)
    , blid(0)
    , flid(0)
    , bnid(0)
    , fnid(0)
    , jct(0)
    , blid2(0)
    , blid3(0)
    , blid4(0)
    , flid2(0)
    , flid3(0)
    , flid4(0)
    , clossid(0)
    , span(0.0)
    , lcnt(0)
    , lno(0)  {
    }
  Lane_(const ContainerAllocator& _alloc)
    : lnid(0)
    , did(0)
    , blid(0)
    , flid(0)
    , bnid(0)
    , fnid(0)
    , jct(0)
    , blid2(0)
    , blid3(0)
    , blid4(0)
    , flid2(0)
    , flid3(0)
    , flid4(0)
    , clossid(0)
    , span(0.0)
    , lcnt(0)
    , lno(0)  {
  (void)_alloc;
    }



   typedef int32_t _lnid_type;
  _lnid_type lnid;

   typedef int32_t _did_type;
  _did_type did;

   typedef int32_t _blid_type;
  _blid_type blid;

   typedef int32_t _flid_type;
  _flid_type flid;

   typedef int32_t _bnid_type;
  _bnid_type bnid;

   typedef int32_t _fnid_type;
  _fnid_type fnid;

   typedef int32_t _jct_type;
  _jct_type jct;

   typedef int32_t _blid2_type;
  _blid2_type blid2;

   typedef int32_t _blid3_type;
  _blid3_type blid3;

   typedef int32_t _blid4_type;
  _blid4_type blid4;

   typedef int32_t _flid2_type;
  _flid2_type flid2;

   typedef int32_t _flid3_type;
  _flid3_type flid3;

   typedef int32_t _flid4_type;
  _flid4_type flid4;

   typedef int32_t _clossid_type;
  _clossid_type clossid;

   typedef double _span_type;
  _span_type span;

   typedef int32_t _lcnt_type;
  _lcnt_type lcnt;

   typedef int32_t _lno_type;
  _lno_type lno;




  typedef boost::shared_ptr< ::map_file::Lane_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::map_file::Lane_<ContainerAllocator> const> ConstPtr;

}; // struct Lane_

typedef ::map_file::Lane_<std::allocator<void> > Lane;

typedef boost::shared_ptr< ::map_file::Lane > LanePtr;
typedef boost::shared_ptr< ::map_file::Lane const> LaneConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::map_file::Lane_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::map_file::Lane_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace map_file

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'std_msgs': ['/opt/ros/indigo/share/std_msgs/cmake/../msg'], 'map_file': ['/home/hj/catkin_ws/src/data/packages/map_file/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::map_file::Lane_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::map_file::Lane_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::map_file::Lane_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::map_file::Lane_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::map_file::Lane_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::map_file::Lane_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::map_file::Lane_<ContainerAllocator> >
{
  static const char* value()
  {
    return "14eee265f5c4b4e93a294e03e3451866";
  }

  static const char* value(const ::map_file::Lane_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x14eee265f5c4b4e9ULL;
  static const uint64_t static_value2 = 0x3a294e03e3451866ULL;
};

template<class ContainerAllocator>
struct DataType< ::map_file::Lane_<ContainerAllocator> >
{
  static const char* value()
  {
    return "map_file/Lane";
  }

  static const char* value(const ::map_file::Lane_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::map_file::Lane_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int32 lnid\n\
int32 did\n\
int32 blid\n\
int32 flid\n\
int32 bnid\n\
int32 fnid\n\
int32 jct\n\
int32 blid2\n\
int32 blid3\n\
int32 blid4\n\
int32 flid2\n\
int32 flid3\n\
int32 flid4\n\
int32 clossid\n\
float64 span\n\
int32 lcnt\n\
int32 lno\n\
";
  }

  static const char* value(const ::map_file::Lane_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::map_file::Lane_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.lnid);
      stream.next(m.did);
      stream.next(m.blid);
      stream.next(m.flid);
      stream.next(m.bnid);
      stream.next(m.fnid);
      stream.next(m.jct);
      stream.next(m.blid2);
      stream.next(m.blid3);
      stream.next(m.blid4);
      stream.next(m.flid2);
      stream.next(m.flid3);
      stream.next(m.flid4);
      stream.next(m.clossid);
      stream.next(m.span);
      stream.next(m.lcnt);
      stream.next(m.lno);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Lane_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::map_file::Lane_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::map_file::Lane_<ContainerAllocator>& v)
  {
    s << indent << "lnid: ";
    Printer<int32_t>::stream(s, indent + "  ", v.lnid);
    s << indent << "did: ";
    Printer<int32_t>::stream(s, indent + "  ", v.did);
    s << indent << "blid: ";
    Printer<int32_t>::stream(s, indent + "  ", v.blid);
    s << indent << "flid: ";
    Printer<int32_t>::stream(s, indent + "  ", v.flid);
    s << indent << "bnid: ";
    Printer<int32_t>::stream(s, indent + "  ", v.bnid);
    s << indent << "fnid: ";
    Printer<int32_t>::stream(s, indent + "  ", v.fnid);
    s << indent << "jct: ";
    Printer<int32_t>::stream(s, indent + "  ", v.jct);
    s << indent << "blid2: ";
    Printer<int32_t>::stream(s, indent + "  ", v.blid2);
    s << indent << "blid3: ";
    Printer<int32_t>::stream(s, indent + "  ", v.blid3);
    s << indent << "blid4: ";
    Printer<int32_t>::stream(s, indent + "  ", v.blid4);
    s << indent << "flid2: ";
    Printer<int32_t>::stream(s, indent + "  ", v.flid2);
    s << indent << "flid3: ";
    Printer<int32_t>::stream(s, indent + "  ", v.flid3);
    s << indent << "flid4: ";
    Printer<int32_t>::stream(s, indent + "  ", v.flid4);
    s << indent << "clossid: ";
    Printer<int32_t>::stream(s, indent + "  ", v.clossid);
    s << indent << "span: ";
    Printer<double>::stream(s, indent + "  ", v.span);
    s << indent << "lcnt: ";
    Printer<int32_t>::stream(s, indent + "  ", v.lcnt);
    s << indent << "lno: ";
    Printer<int32_t>::stream(s, indent + "  ", v.lno);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MAP_FILE_MESSAGE_LANE_H
